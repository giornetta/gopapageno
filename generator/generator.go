package generator

import (
	"fmt"
	"github.com/giornetta/gopapageno"
	"log"
	"os"
	"path"
)

const (
	GeneratedLexerFilename     = "lexer.pg.go"
	GeneratedParserFilename    = "parser.pg.go"
	GeneratedMainFilename      = "main.pg.go"
	GeneratedBenchmarkFilename = "benchmark_test.go"
)

type Options struct {
	LexerDescriptionFilename  string
	ParserDescriptionFilename string
	OutputDirectory           string
	TypesOnly                 bool
	GenerateBenchmarks        bool

	Strategy gopapageno.ParsingStrategy

	Logger *log.Logger
}

func Generate(opts *Options) error {
	lexerFile, err := os.Open(opts.LexerDescriptionFilename)
	if err != nil {
		return fmt.Errorf("could not open lexer description file: %w", err)
	}

	lexerDesc, err := parseLexerDescription(lexerFile, opts.Logger)
	if err != nil {
		return fmt.Errorf("could not parse lexer description: %w", err)
	}

	if err := lexerDesc.compile(); err != nil {
		return fmt.Errorf("could not compile lexer: %w", err)
	}

	if err := lexerFile.Close(); err != nil {
		opts.Logger.Printf("could not close lexer description file: %v\n", err)
	}

	parserFile, err := os.Open(opts.ParserDescriptionFilename)
	if err != nil {
		return fmt.Errorf("could not open parser file: %w", err)
	}

	parserDesc, err := parseGrammarDescription(parserFile, opts)
	if err != nil {
		return fmt.Errorf("could not parse parser description: %w", err)
	}

	if err := parserDesc.compile(opts); err != nil {
		return fmt.Errorf("could not compile parser: %w", err)
	}

	if err := parserFile.Close(); err != nil {
		opts.Logger.Printf("could not close parser description file: %v\n", err)
	}

	packageName, err := emitDirectory(opts)
	if err != nil {
		return fmt.Errorf("could not generate output directory: %w", err)
	}

	if err := lexerDesc.emit(opts, packageName); err != nil {
		return fmt.Errorf("could not generate lexer file: %w", err)
	}

	if err := parserDesc.emit(opts, packageName); err != nil {
		return fmt.Errorf("could not generate lexer file: %w", err)
	}

	if !opts.TypesOnly {
		if err := emitMainFile(opts, packageName); err != nil {
			return fmt.Errorf("could not generate main file: %w", err)
		}
	}

	if opts.GenerateBenchmarks {
		if err := emitBenchmarkFile(opts, packageName); err != nil {
			return fmt.Errorf("could not generate benchmark file: %w", err)
		}
	}

	return nil
}

// emitDirectory creates the output directory if it doesn't exist.
func emitDirectory(opts *Options) (string, error) {
	s, err := os.Stat(opts.OutputDirectory)
	if err != nil {
		if os.IsNotExist(err) {
			opts.Logger.Printf("Creating directory %s...\n", opts.OutputDirectory)
			if err = os.Mkdir(opts.OutputDirectory, os.ModeDir); err != nil {
				return "", fmt.Errorf("could not create output directory %s: %w", opts.OutputDirectory, err)
			}
		}

		return "", err
	}
	if !s.IsDir() {
		return "", fmt.Errorf("%s is not a directory", opts.OutputDirectory)
	}

	packageName := "main"
	if opts.TypesOnly {
		packageName = s.Name()
	}

	return packageName, nil
}

func emitMainFile(opts *Options, packageName string) error {
	mainPath := path.Join(opts.OutputDirectory, GeneratedMainFilename)

	opts.Logger.Printf("Creating main file %s...\n", mainPath)

	mainFile, err := os.Create(mainPath)
	if err != nil {
		return fmt.Errorf("could not create main file %s: %w", mainPath, err)
	}

	fmt.Fprintf(mainFile, "// Code generated by Gopapageno.\n")
	fmt.Fprintf(mainFile, "package %s\n", packageName)
	fmt.Fprintf(mainFile, `
import (
	"context"
	"flag"
	"fmt"
	"github.com/giornetta/gopapageno"
	"io"
	"log"
	"os"
	"time"
)

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func run() error {
	start := time.Now()

	sourceFlag := flag.String("f", "", "source file")
	concurrencyFlag := flag.Int("c", 1, "number of concurrent goroutines to spawn")
	strategyFlag := flag.String("s", "sweep", "parsing strategy to execute")
	logFlag := flag.Bool("log", false, "enable logging")
	avgTokensFlag := flag.Int("avg", 4, "average length of tokens")

	cpuProfileFlag := flag.String("cpuprof", "", "output file for CPU profiling")
	memProfileFlag := flag.String("memprof", "", "output file for Memory profiling")

	flag.Parse()

	bytes, err := os.ReadFile(*sourceFlag)
	if err != nil {
		return fmt.Errorf("could not read source file %%s: %%w", *sourceFlag, err)
	}

	logOut := io.Discard
	if *logFlag {
		logOut = os.Stderr
	}

	cpuProfileWriter := io.Discard
	if *cpuProfileFlag != "" {
		cpuProfileWriter, err = os.Create(*cpuProfileFlag)
		if err != nil {
			cpuProfileWriter = io.Discard
		}
	}

	memProfileWriter := io.Discard
	if *memProfileFlag != "" {
		memProfileWriter, err = os.Create(*memProfileFlag)
		if err != nil {
			memProfileWriter = io.Discard
		}
	}

	strat := gopapageno.ReductionSweep
	if *strategyFlag == "parallel" {
		strat = gopapageno.ReductionParallel
	} else if *strategyFlag == "mixed" {
		strat = gopapageno.ReductionMixed	
	}

	r := gopapageno.NewRunner(
		NewLexer(),
		NewGrammar(),
		gopapageno.WithConcurrency(*concurrencyFlag),
		gopapageno.WithLogging(log.New(logOut, "", 0)),
		gopapageno.WithCPUProfiling(cpuProfileWriter),
		gopapageno.WithMemoryProfiling(memProfileWriter),
		gopapageno.WithReductionStrategy(strat),
		gopapageno.WithAverageTokenLength(*avgTokensFlag),
	)

	ctx := context.Background()

	root, err := r.Run(ctx, bytes)
	if err != nil {
		return fmt.Errorf("could not parse source: %%w", err)
	}

	fmt.Printf("Parsing took: %%v\n", time.Since(start))

	// fmt.Printf("Result: %%v\n", *root.Value.(*int64))
	ctx, cancel := context.WithTimeout(ctx, time.Second)
	defer cancel()

	h, err := root.Height(ctx)
	if err != nil {
		return err
	}

	fmt.Printf("Height: %%d\n", h)
	if h < 10 {
		fmt.Println(SprintToken[int64](root))
	}

	return nil
}
`)

	if err := mainFile.Close(); err != nil {
		opts.Logger.Printf("Could not close main file: %v\n", err)
	}

	return nil
}

func emitBenchmarkFile(opts *Options, packageName string) error {
	gPath := path.Join(opts.OutputDirectory, GeneratedBenchmarkFilename)
	opts.Logger.Printf("Creating parser file %s...\n", gPath)

	gFile, err := os.Create(gPath)
	if err != nil {
		return fmt.Errorf("could not create parser file %s: %w", gPath, err)
	}

	fmt.Fprintf(gFile, "package %s\n\n", packageName)
	fmt.Fprintf(gFile, `import (
	"context"
	"flag"
	"fmt"
	"github.com/giornetta/gopapageno"
	"github.com/giornetta/gopapageno/benchmark"
	"os"
	"path"
	"runtime"
	"testing"
)

const baseFolder = "../data/"

var table = map[string]any{
}
var reductionFlag string

func TestMain(m *testing.M) {
	flag.StringVar(&reductionFlag, "s", "sweep", "parsing strategy to execute")

	flag.Parse()

	os.Exit(m.Run())
}

func BenchmarkParse(b *testing.B) {
	strat := gopapageno.ReductionSweep
	if reductionFlag == "parallel" {
		strat = gopapageno.ReductionParallel
	} else if reductionFlag == "mixed" {
		strat = gopapageno.ReductionMixed
	}

	threads := runtime.NumCPU()

	for filename, _ := range table {
		for c := 1; c <= threads; c = min(c*2, threads) {
			b.Run(fmt.Sprintf("%%s/%%dT", filename, c), func(b *testing.B) {
				r := gopapageno.NewRunner(
					NewLexer(),
					NewGrammar(),
					gopapageno.WithConcurrency(c),
					gopapageno.WithReductionStrategy(strat))


				b.ResetTimer()

				benchmark.Run(b, r, path.Join(baseFolder, filename))
			})

			runtime.GC()

			if c == threads {
				break
			}
		}
	}
}

func TestProfile(t *testing.T) {
	c := runtime.NumCPU()
	avgLen := gopapageno.DefaultAverageTokenLength
	strat := gopapageno.ReductionParallel

	var filename string

	file := path.Join(baseFolder, filename)

	bytes, err := os.ReadFile(file)
	if err != nil {
		t.Fatalf("could not read source file %%s: %%v", file, err)
	}

	r := gopapageno.NewRunner(
		NewLexer(),
		NewGrammar(),
		gopapageno.WithConcurrency(c),
		gopapageno.WithAverageTokenLength(avgLen),
		gopapageno.WithReductionStrategy(strat),
	)

	ctx := context.Background()

	_, err = r.Run(ctx, bytes)
	if err != nil {
		t.Fatalf("could not parse source: %%v", err)
	}
}

`)
	return nil
}
