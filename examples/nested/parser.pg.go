// Code generated by Gopapageno; DO NOT EDIT.
package main

import (
	"fmt"
	"github.com/giornetta/gopapageno"
	"strings"
)

import (
	"math"
)

var parserPools []*gopapageno.Pool[int64]

func ParserPreallocMem(inputSize int, numThreads int) {
	parserPools = make([]*gopapageno.Pool[int64], numThreads)

	avgCharsPerNumber := float64(2)
	poolSizePerThread := int(math.Ceil((float64(inputSize) / avgCharsPerNumber) / float64(numThreads)))

	for i := 0; i < numThreads; i++ {
		parserPools[i] = gopapageno.NewPool[int64](poolSizePerThread)
	}
}

// Non-terminals
const (
	E = gopapageno.TokenEmpty + 1 + iota
	S
	V
)

// Terminals
const (
	NUMBER = gopapageno.TokenTerm + 1 + iota
	OPERATOR
)

func SprintToken[TokenValue any](root *gopapageno.Token) string {
	var sprintRec func(t *gopapageno.Token, sb *strings.Builder, indent string)

	sprintRec = func(t *gopapageno.Token, sb *strings.Builder, indent string) {
		if t == nil {
			return
		}

		sb.WriteString(indent)
		if t.Next == nil {
			sb.WriteString("└── ")
			indent += "    "
		} else {
			sb.WriteString("├── ")
			indent += "|   "
		}

		switch t.Type {
		case E:
			sb.WriteString("E")
		case S:
			sb.WriteString("S")
		case V:
			sb.WriteString("V")
		case gopapageno.TokenEmpty:
			sb.WriteString("Empty")
		case NUMBER:
			sb.WriteString("NUMBER")
		case OPERATOR:
			sb.WriteString("OPERATOR")
		case gopapageno.TokenTerm:
			sb.WriteString("Term")
		default:
			sb.WriteString("Unknown")
		}
		if t.Value != nil {
			sb.WriteString(fmt.Sprintf(": %v", *t.Value.(*TokenValue)))
		}
		sb.WriteString("\n")

		sprintRec(t.Child, sb, indent)
		sprintRec(t.Next, sb, indent[:len(indent)-4])
	}

	var sb strings.Builder

	sprintRec(root, &sb, "")

	return sb.String()
}

func NewGrammar() *gopapageno.Grammar {
	numTerminals := uint16(3)
	numNonTerminals := uint16(4)

	maxRHSLen := 3
	rules := []gopapageno.Rule{
		{S, []gopapageno.TokenType{E}, gopapageno.RuleSimple},
		{E, []gopapageno.TokenType{E, OPERATOR, E}, gopapageno.RuleCombine},
		{E, []gopapageno.TokenType{E, OPERATOR, V}, gopapageno.RuleAppendRight},
		{S, []gopapageno.TokenType{S}, gopapageno.RuleSimple},
		{E, []gopapageno.TokenType{V, OPERATOR, E}, gopapageno.RuleAppendLeft},
		{E, []gopapageno.TokenType{V, OPERATOR, V}, gopapageno.RuleCyclic},
		{V, []gopapageno.TokenType{NUMBER}, gopapageno.RuleSimple},
	}
	compressedRules := []uint16{0, 0, 4, 1, 11, 2, 29, 3, 32, 32769, 50, 2, 0, 1, 32770, 16, 0, 0, 2, 1, 23, 3, 26, 1, 1, 0, 1, 2, 0, 2, 3, 0, 0, 0, 1, 32770, 37, 0, 0, 2, 1, 44, 3, 47, 1, 4, 0, 1, 5, 0, 3, 6, 0}

	maxPrefixLength := 5
	prefixes := [][]gopapageno.TokenType{
		{V, OPERATOR, V},
		{V, OPERATOR, V, OPERATOR, V},
	}
	precMatrix := [][]gopapageno.Precedence{
		{gopapageno.PrecEquals, gopapageno.PrecYields, gopapageno.PrecYields},
		{gopapageno.PrecTakes, gopapageno.PrecEmpty, gopapageno.PrecTakes},
		{gopapageno.PrecTakes, gopapageno.PrecYields, gopapageno.PrecEquals},
	}
	bitPackedMatrix := []uint64{
		26772,
	}

	fn := func(rule uint16, lhs *gopapageno.Token, rhs []*gopapageno.Token, thread int) {
		var ruleType gopapageno.RuleType
		switch rule {
		case 0:
			ruleType = gopapageno.RuleSimple

			S0 := lhs
			E1 := rhs[0]

			S0.Child = E1
			S0.LastChild = E1

			{
				S0.Value = E1.Value
			}
			_ = E1
		case 1:
			ruleType = gopapageno.RuleCombine

			E0 := lhs
			E1 := rhs[0]
			OPERATOR2 := rhs[1]
			E3 := rhs[2]

			E0.LastChild.Next = OPERATOR2
			OPERATOR2.Next = E3.Child
			E0.LastChild = E3.LastChild

			{
				newValue := parserPools[thread].Get()
				*newValue = *E1.Value.(*int64) + *E3.Value.(*int64)
				E0.Value = newValue
			}
			_ = E1
			_ = OPERATOR2
			_ = E3
		case 2:
			ruleType = gopapageno.RuleAppendRight

			E0 := lhs
			E1 := rhs[0]
			OPERATOR2 := rhs[1]
			V3 := rhs[2]

			E0.LastChild.Next = OPERATOR2
			OPERATOR2.Next = V3
			E0.LastChild = V3

			{
				newValue := parserPools[thread].Get()
				*newValue = *E1.Value.(*int64) + *V3.Value.(*int64)
				E0.Value = newValue
			}
			_ = E1
			_ = OPERATOR2
			_ = V3
		case 3:
			ruleType = gopapageno.RuleSimple

			S0 := lhs
			S1 := rhs[0]

			S0.Child = S1
			S0.LastChild = S1

			{
				S0.Value = S1.Value
			}
			_ = S1
		case 4:
			ruleType = gopapageno.RuleAppendLeft

			E0 := lhs
			V1 := rhs[0]
			OPERATOR2 := rhs[1]
			E3 := rhs[2]

			oldChild := E0
			E0.Child = V1
			V1.Next = OPERATOR2
			OPERATOR2.Next = E3
			E3.Next = oldChild

			{
				newValue := parserPools[thread].Get()
				*newValue = *V1.Value.(*int64) + *E3.Value.(*int64)
				E0.Value = newValue
			}
			_ = V1
			_ = OPERATOR2
			_ = E3
		case 5:
			ruleType = gopapageno.RuleCyclic

			E0 := lhs
			V1 := rhs[0]
			OPERATOR2 := rhs[1]
			V3 := rhs[2]

			E0.Child = V1
			V1.Next = OPERATOR2
			OPERATOR2.Next = V3
			E0.LastChild = V3

			{
				newValue := parserPools[thread].Get()
				*newValue = *V1.Value.(*int64) + *V3.Value.(*int64)
				E0.Value = newValue
			}
			_ = V1
			_ = OPERATOR2
			_ = V3
		case 6:
			ruleType = gopapageno.RuleSimple

			V0 := lhs
			NUMBER1 := rhs[0]

			V0.Child = NUMBER1
			V0.LastChild = NUMBER1

			{
				V0.Value = NUMBER1.Value
			}
			_ = NUMBER1
		}
		_ = ruleType
	}

	return &gopapageno.Grammar{
		NumTerminals:              numTerminals,
		NumNonterminals:           numNonTerminals,
		MaxRHSLength:              maxRHSLen,
		Rules:                     rules,
		CompressedRules:           compressedRules,
		PrecedenceMatrix:          precMatrix,
		BitPackedPrecedenceMatrix: bitPackedMatrix,
		MaxPrefixLength:           maxPrefixLength,
		Prefixes:                  prefixes,
		Func:                      fn,
		ParsingStrategy:           gopapageno.COPP,
		PreambleFunc:              ParserPreallocMem,
	}
}
