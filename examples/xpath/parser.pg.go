// Code generated by Gopapageno; DO NOT EDIT.
package xpath

import "github.com/giornetta/gopapageno"

import (
	"sync"
)

var reductionPool = &sync.Pool{
	New: func() interface{} {
		return new(xpath.Reduction)
	},
}

var parserElementsPools []*gopapageno.Pool[xpath.Element]

// ParserPreallocMem initializes all the memory pools required by the semantic function of the parser.
func ParserPreallocMem(inputSize int, numThreads int) {
	poolSizePerThread := 10000

	parserElementsPools = make([]*gopapageno.Pool[xpath.Element], numThreads)
	for i := 0; i < numThreads; i++ {
		parserElementsPools[i] = gopapageno.NewPool[xpath.Element](poolSizePerThread)
	}
}

// Non-terminals
const (
	ELEM = gopapageno.TokenEmpty + 1 + iota
	NEW_AXIOM
)

// Terminals
const (
	CLOSETAG = gopapageno.TokenTerm + 1 + iota
	OPENCLOSETAG
	OPENTAG
	TEXT
)

func NewParser(opts ...gopapageno.ParserOpt) *gopapageno.Parser {
	numTerminals := uint16(5)
	numNonTerminals := uint16(3)

	maxRHSLen := 4
	rules := []gopapageno.Rule{
		{NEW_AXIOM, []gopapageno.TokenType{ELEM}},
		{ELEM, []gopapageno.TokenType{ELEM, OPENCLOSETAG}},
		{ELEM, []gopapageno.TokenType{ELEM, OPENTAG, ELEM, CLOSETAG}},
		{ELEM, []gopapageno.TokenType{ELEM, OPENTAG, CLOSETAG}},
		{ELEM, []gopapageno.TokenType{ELEM, TEXT}},
		{ELEM, []gopapageno.TokenType{OPENCLOSETAG}},
		{ELEM, []gopapageno.TokenType{OPENTAG, ELEM, CLOSETAG}},
		{ELEM, []gopapageno.TokenType{OPENTAG, CLOSETAG}},
		{ELEM, []gopapageno.TokenType{TEXT}},
	}
	compressedRules := []uint16{0, 0, 4, 1, 11, 32770, 44, 32771, 47, 32772, 65, 2, 0, 3, 32770, 20, 32771, 23, 32772, 41, 1, 1, 0, 0, 0, 2, 1, 30, 32769, 38, 0, 0, 1, 32769, 35, 1, 2, 0, 1, 3, 0, 1, 4, 0, 1, 5, 0, 0, 0, 2, 1, 54, 32769, 62, 0, 0, 1, 32769, 59, 1, 6, 0, 1, 7, 0, 1, 8, 0}

	precMatrix := [][]gopapageno.Precedence{
		{gopapageno.PrecEquals, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields},
		{gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes},
		{gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes},
		{gopapageno.PrecTakes, gopapageno.PrecEquals, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields},
		{gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes},
	}
	bitPackedMatrix := []uint64{
		749874088421377,
	}

	fn := func(rule uint16, lhs *gopapageno.Token, rhs []*gopapageno.Token, thread int) {
		switch rule {
		case 0:
			NEW_AXIOM0 := lhs
			ELEM1 := rhs[0]

			NEW_AXIOM0.Child = ELEM1

			{
				NEW_AXIOM0.Value = ELEM1.Value
			}
		case 1:
			ELEM0 := lhs
			ELEM1 := rhs[0]
			OPENCLOSETAG2 := rhs[1]

			ELEM0.Child = ELEM1
			ELEM1.Next = OPENCLOSETAG2

			{
				openCloseTag := OPENCLOSETAG2.Value.(xpath.OpenCloseTagSemanticValue)

				element := parserElementsPools[thread].Get()
				element.SetFromSingleTag(openCloseTag)

				generativeNonTerminal := ELEM1.Value.(xpath.NonTerminal)
				reducedNonTerminal := xpath.NewNonTerminal().SetNode(element).SetDirectChildAndInheritItsChildren(generativeNonTerminal)

				reduction := reductionPool.Get().(*xpath.Reduction)
				reduction.Setup(reducedNonTerminal, generativeNonTerminal, nil)
				reduction.Handle()
				reductionPool.Put(reduction)

				ELEM0.Value = reducedNonTerminal
			}
		case 2:
			ELEM0 := lhs
			ELEM1 := rhs[0]
			OPENTAG2 := rhs[1]
			ELEM3 := rhs[2]
			CLOSETAG4 := rhs[3]

			ELEM0.Child = ELEM1
			ELEM1.Next = OPENTAG2
			OPENTAG2.Next = ELEM3
			ELEM3.Next = CLOSETAG4

			{
				openTag := OPENTAG2.Value.(xpath.OpenTagSemanticValue)
				closeTag := CLOSETAG4.Value.(xpath.CloseTagSemanticValue)

				element := parserElementsPools[thread].Get()
				element.SetFromExtremeTags(openTag, closeTag)

				generativeNonTerminal := ELEM1.Value.(xpath.NonTerminal)
				wrappedNonTerminal := ELEM3.Value.(xpath.NonTerminal)
				reducedNonTerminal := xpath.NewNonTerminal().SetNode(element).SetDirectChildAndInheritItsChildren(generativeNonTerminal)

				reduction := reductionPool.Get().(*xpath.Reduction)
				reduction.Setup(reducedNonTerminal, generativeNonTerminal, wrappedNonTerminal)
				reduction.Handle()
				reductionPool.Put(reduction)

				ELEM0.Value = reducedNonTerminal
			}
		case 3:
			ELEM0 := lhs
			ELEM1 := rhs[0]
			OPENTAG2 := rhs[1]
			CLOSETAG3 := rhs[2]

			ELEM0.Child = ELEM1
			ELEM1.Next = OPENTAG2
			OPENTAG2.Next = CLOSETAG3

			{
				openTag := OPENTAG2.Value.(xpath.OpenTagSemanticValue)
				closeTag := CLOSETAG3.Value.(xpath.CloseTagSemanticValue)

				element := parserElementsPools[thread].Get()
				element.SetFromExtremeTags(openTag, closeTag)

				generativeNonTerminal := ELEM1.Value.(xpath.NonTerminal)
				reducedNonTerminal := xpath.NewNonTerminal().SetNode(element).SetDirectChildAndInheritItsChildren(generativeNonTerminal)

				reduction := reductionPool.Get().(*xpath.Reduction)
				reduction.Setup(reducedNonTerminal, generativeNonTerminal, nil)
				reduction.Handle()
				reductionPool.Put(reduction)

				ELEM0.Value = reducedNonTerminal
			}
		case 4:
			ELEM0 := lhs
			ELEM1 := rhs[0]
			TEXT2 := rhs[1]

			ELEM0.Child = ELEM1
			ELEM1.Next = TEXT2

			{
				tsv := TEXT2.Value.(xpath.TextSemanticValue)

				text := new(xpath.Text)
				text.SetFromText(tsv)

				generativeNonTerminal := ELEM1.Value.(xpath.NonTerminal)

				reducedNonTerminal := xpath.NewNonTerminal().SetNode(text).SetDirectChildAndInheritItsChildren(generativeNonTerminal)

				reduction := reductionPool.Get().(*xpath.Reduction)
				reduction.Setup(reducedNonTerminal, generativeNonTerminal, nil)
				reduction.Handle()
				reductionPool.Put(reduction)

				ELEM0.Value = reducedNonTerminal
			}
		case 5:
			ELEM0 := lhs
			OPENCLOSETAG1 := rhs[0]

			ELEM0.Child = OPENCLOSETAG1

			{
				openCloseTag := OPENCLOSETAG1.Value.(xpath.OpenCloseTagSemanticValue)

				element := parserElementsPools[thread].Get()
				element.SetFromSingleTag(openCloseTag)

				reducedNonTerminal := xpath.NewNonTerminal().SetNode(element)

				reduction := reductionPool.Get().(*xpath.Reduction)
				reduction.Setup(reducedNonTerminal, nil, nil)
				reduction.Handle()
				reductionPool.Put(reduction)

				ELEM0.Value = reducedNonTerminal
			}
		case 6:
			ELEM0 := lhs
			OPENTAG1 := rhs[0]
			ELEM2 := rhs[1]
			CLOSETAG3 := rhs[2]

			ELEM0.Child = OPENTAG1
			OPENTAG1.Next = ELEM2
			ELEM2.Next = CLOSETAG3

			{
				openTag := OPENTAG1.Value.(xpath.OpenTagSemanticValue)
				closeTag := CLOSETAG3.Value.(xpath.CloseTagSemanticValue)

				element := parserElementsPools[thread].Get()
				element.SetFromExtremeTags(openTag, closeTag)

				wrappedNonTerminal := ELEM2.Value.(xpath.NonTerminal)
				reducedNonTerminal := xpath.NewNonTerminal().SetNode(element)

				reduction := reductionPool.Get().(*xpath.Reduction)
				reduction.Setup(reducedNonTerminal, nil, wrappedNonTerminal)
				reduction.Handle()
				reductionPool.Put(reduction)

				ELEM0.Value = reducedNonTerminal
			}
		case 7:
			ELEM0 := lhs
			OPENTAG1 := rhs[0]
			CLOSETAG2 := rhs[1]

			ELEM0.Child = OPENTAG1
			OPENTAG1.Next = CLOSETAG2

			{
				openTag := OPENTAG1.Value.(xpath.OpenTagSemanticValue)
				closeTag := CLOSETAG2.Value.(xpath.CloseTagSemanticValue)

				element := parserElementsPools[thread].Get()
				element.SetFromExtremeTags(openTag, closeTag)

				reducedNonTerminal := xpath.NewNonTerminal().SetNode(element)

				reduction := reductionPool.Get().(*xpath.Reduction)
				reduction.Setup(reducedNonTerminal, nil, nil)
				reduction.Handle()
				reductionPool.Put(reduction)

				ELEM0.Value = reducedNonTerminal
			}
		case 8:
			ELEM0 := lhs
			TEXT1 := rhs[0]

			ELEM0.Child = TEXT1

			{
				tsv := TEXT1.Value.(xpath.TextSemanticValue)

				text := new(xpath.Text)
				text.SetFromText(tsv)

				reducedNonTerminal := xpath.NewNonTerminal().SetNode(text)

				reduction := reductionPool.Get().(*xpath.Reduction)
				reduction.Setup(reducedNonTerminal, nil, nil)
				reduction.Handle()
				reductionPool.Put(reduction)

				ELEM0.Value = reducedNonTerminal
			}
		}
	}

	return gopapageno.NewParser(
		NewLexer(),
		numTerminals,
		numNonTerminals,
		maxRHSLen,
		rules,
		compressedRules,
		precMatrix,
		bitPackedMatrix,
		fn,
		opts...)
}
