// Code generated by Gopapageno; DO NOT EDIT.
package xpath

import (
	"github.com/giornetta/gopapageno"
	"strings"
	"fmt"
)

import (
    "sync"
    "github.com/giornetta/gopapageno/ext/xpath"
)

var reductionPool = &sync.Pool{
	New: func() interface{} {
		return new(xpath.Reduction)
	},
}

var parserElementsPools []*gopapageno.Pool[xpath.Element]

// ParserPreallocMem initializes all the memory pools required by the semantic function of the parser.
func ParserPreallocMem(inputSize int, numThreads int) {
    poolSizePerThread := 10000

    parserElementsPools = make([]*gopapageno.Pool[xpath.Element], numThreads)
    for i := 0; i < numThreads; i++ {
        parserElementsPools[i] = gopapageno.NewPool[xpath.Element](poolSizePerThread)
    }
}


// Non-terminals
const (
	ELEM = gopapageno.TokenEmpty + 1 + iota
)

// Terminals
const (
	CLOSETAG = gopapageno.TokenTerm + 1 + iota
	OPENCLOSETAG
	OPENTAG
	TEXT
)

func SprintToken[ValueType any](root *gopapageno.Token) string {
	var sprintRec func(t *gopapageno.Token, sb *strings.Builder, indent string)

	sprintRec = func(t *gopapageno.Token, sb *strings.Builder, indent string) {
		if t == nil {
			return
		}

		sb.WriteString(indent)
		if t.Next == nil {
			sb.WriteString("└── ")
			indent += "    "
		} else {
			sb.WriteString("├── ")
			indent += "|   "
		}

		switch t.Type {
		case ELEM:
			sb.WriteString("ELEM")
		case gopapageno.TokenEmpty:
			sb.WriteString("Empty")
		case CLOSETAG:
			sb.WriteString("CLOSETAG")
		case OPENCLOSETAG:
			sb.WriteString("OPENCLOSETAG")
		case OPENTAG:
			sb.WriteString("OPENTAG")
		case TEXT:
			sb.WriteString("TEXT")
		case gopapageno.TokenTerm:
			sb.WriteString("Term")
		default:
			sb.WriteString("Unknown")
		}

		if t.Value != nil {
			if v, ok := any(t.Value).(*ValueType); ok {
				sb.WriteString(fmt.Sprintf(": %v", *v))
			}
		}
		
		sb.WriteString("\n")
		
		sprintRec(t.Child, sb, indent)
		sprintRec(t.Next, sb, indent[:len(indent)-4])
	}

	var sb strings.Builder
	
	sprintRec(root, &sb, "")
	
	return sb.String()
}

func NewGrammar() *gopapageno.Grammar {
	numTerminals := uint16(5)
	numNonTerminals := uint16(2)

	maxRHSLen := 3
	rules := []gopapageno.Rule{
		{ELEM, []gopapageno.TokenType{OPENCLOSETAG}, gopapageno.RuleSimple},
		{ELEM, []gopapageno.TokenType{OPENTAG, ELEM, CLOSETAG}, gopapageno.RuleSimple},
		{ELEM, []gopapageno.TokenType{OPENTAG, CLOSETAG}, gopapageno.RuleSimple},
		{ELEM, []gopapageno.TokenType{TEXT}, gopapageno.RuleSimple},
	}
	compressedRules := []uint16{0, 0, 3, 32770, 9, 32771, 12, 32772, 30, 1, 0, 0, 0, 0, 2, 1, 19, 32769, 27, 0, 0, 1, 32769, 24, 1, 1, 0, 1, 2, 0, 1, 3, 0	}

	precMatrix := [][]gopapageno.Precedence{
		{gopapageno.PrecEquals, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields},
		{gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes},
		{gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes},
		{gopapageno.PrecTakes, gopapageno.PrecEquals, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields},
		{gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecTakes},
	}
	bitPackedMatrix := []uint64{
		750230570707284, 
	}

	fn := func(ruleDescription uint16, ruleFlags gopapageno.RuleFlags, lhs *gopapageno.Token, rhs []*gopapageno.Token, thread int){
		switch ruleDescription {
		case 0:
			ELEM0 := lhs
			OPENCLOSETAG1 := rhs[0]

			ELEM0.Child = OPENCLOSETAG1
			ELEM0.LastChild = OPENCLOSETAG1

			{
			    openCloseTag := OPENCLOSETAG1.Value.(xpath.OpenCloseTagSemanticValue)
			
			    element := parserElementsPools[thread].Get()
			    element.SetFromSingleTag(openCloseTag)
			
			    reducedNonTerminal := xpath.NewNonTerminal().SetNode(element)
			
			    reduction := reductionPool.Get().(*xpath.Reduction)
			    reduction.Setup(reducedNonTerminal, nil, nil)
			    reduction.Handle()
			    reductionPool.Put(reduction)
			
			    ELEM0.Value = reducedNonTerminal
			}
			_ = OPENCLOSETAG1
		case 1:
			ELEM0 := lhs
			OPENTAG1 := rhs[0]
			ELEM2 := rhs[1]
			CLOSETAG3 := rhs[2]

			ELEM0.Child = OPENTAG1
			OPENTAG1.Next = ELEM2
			ELEM2.Next = CLOSETAG3
			ELEM0.LastChild = CLOSETAG3

			{
			    openTag := OPENTAG1.Value.(xpath.OpenTagSemanticValue)
			    closeTag := CLOSETAG3.Value.(xpath.CloseTagSemanticValue)
			
			    element := parserElementsPools[thread].Get()
			    element.SetFromExtremeTags(openTag, closeTag)
			
			    wrappedNonTerminal := ELEM2.Value.(xpath.NonTerminal)
			    reducedNonTerminal := xpath.NewNonTerminal().SetNode(element)
			
			    reduction := reductionPool.Get().(*xpath.Reduction)
			    reduction.Setup(reducedNonTerminal, nil, wrappedNonTerminal)
			    reduction.Handle()
			    reductionPool.Put(reduction)
			
			    ELEM0.Value = reducedNonTerminal
			}
			_ = OPENTAG1
			_ = ELEM2
			_ = CLOSETAG3
		case 2:
			ELEM0 := lhs
			OPENTAG1 := rhs[0]
			CLOSETAG2 := rhs[1]

			ELEM0.Child = OPENTAG1
			OPENTAG1.Next = CLOSETAG2
			ELEM0.LastChild = CLOSETAG2

			{
			    openTag := OPENTAG1.Value.(xpath.OpenTagSemanticValue)
			    closeTag := CLOSETAG2.Value.(xpath.CloseTagSemanticValue)
			
			    element := parserElementsPools[thread].Get()
			    element.SetFromExtremeTags(openTag, closeTag)
			
			    reducedNonTerminal := xpath.NewNonTerminal().SetNode(element)
			
			    reduction := reductionPool.Get().(*xpath.Reduction)
			    reduction.Setup(reducedNonTerminal, nil, nil)
			    reduction.Handle()
			    reductionPool.Put(reduction)
			
			    ELEM0.Value = reducedNonTerminal
			}
			_ = OPENTAG1
			_ = CLOSETAG2
		case 3:
			ELEM0 := lhs
			TEXT1 := rhs[0]

			ELEM0.Child = TEXT1
			ELEM0.LastChild = TEXT1

			{
			    tsv := TEXT1.Value.(xpath.TextSemanticValue)
			
			    text := new(xpath.Text)
			    text.SetFromText(tsv)
			
			    reducedNonTerminal := xpath.NewNonTerminal().SetNode(text)
			
			    reduction := reductionPool.Get().(*xpath.Reduction)
			    reduction.Setup(reducedNonTerminal, nil, nil)
			    reduction.Handle()
			    reductionPool.Put(reduction)
			
			
			    ELEM0.Value = reducedNonTerminal
			}
			_ = TEXT1
		}
		_ = ruleFlags
	}

	return &gopapageno.Grammar{
		NumTerminals:  numTerminals,
		NumNonterminals: numNonTerminals,
		MaxRHSLength: maxRHSLen,
		Rules: rules,
		CompressedRules: compressedRules,
		PrecedenceMatrix: precMatrix,
		BitPackedPrecedenceMatrix: bitPackedMatrix,
		Func: fn,
		ParsingStrategy: gopapageno.OPP,
		PreambleFunc: LexerPreallocMem,
	}
}

