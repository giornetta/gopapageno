// Code generated by Gopapageno; DO NOT EDIT.
package main

import "github.com/giornetta/gopapageno"

import (
	"math"
)

var parserPools []*gopapageno.Pool[int64]

func ParserPreallocMem(inputSize int, numThreads int) {
	parserPools = make([]*gopapageno.Pool[int64], numThreads)

	avgCharsPerNumber := float64(2)
	poolSizePerThread := int(math.Ceil((float64(inputSize) / avgCharsPerNumber) / float64(numThreads)))

	for i := 0; i < numThreads; i++ {
		parserPools[i] = gopapageno.NewPool[int64](poolSizePerThread)

	}
}

// Non-terminals
const (
	E_S = gopapageno.TokenEmpty + 1 + iota
	NEW_AXIOM
)

// Terminals
const (
	LPAR = gopapageno.TokenTerm + 1 + iota
	NUMBER
	PLUS
	RPAR
)

func NewParser(opts ...gopapageno.ParserOpt) *gopapageno.Parser {
	numTerminals := uint16(5)
	numNonTerminals := uint16(3)

	maxRHSLen := 3
	rules := []gopapageno.Rule{
		{NEW_AXIOM, []gopapageno.TokenType{E_S}},
		{E_S, []gopapageno.TokenType{E_S, PLUS, E_S}},
		{E_S, []gopapageno.TokenType{LPAR, E_S, RPAR}},
		{E_S, []gopapageno.TokenType{NUMBER}},
	}
	compressedRules := []uint16{0, 0, 3, 1, 9, 32769, 22, 32770, 35, 2, 0, 1, 32771, 14, 0, 0, 1, 1, 19, 1, 1, 0, 0, 0, 1, 1, 27, 0, 0, 1, 32772, 32, 1, 2, 0, 1, 3, 0}

	precMatrix := [][]gopapageno.Precedence{
		{gopapageno.PrecEquals, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields},
		{gopapageno.PrecTakes, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecEquals},
		{gopapageno.PrecTakes, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecTakes, gopapageno.PrecTakes},
		{gopapageno.PrecTakes, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecAssociative, gopapageno.PrecTakes},
		{gopapageno.PrecTakes, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecTakes, gopapageno.PrecTakes},
	}
	bitPackedMatrix := []uint64{
		706439041779713,
	}

	fn := func(rule uint16, lhs *gopapageno.Token, rhs []*gopapageno.Token, thread int) {
		switch rule {
		case 0:
			NEW_AXIOM0 := lhs
			E_S1 := rhs[0]

			NEW_AXIOM0.Child = E_S1

			{
				NEW_AXIOM0.Value = E_S1.Value
			}
		case 1:
			E_S0 := lhs
			E_S1 := rhs[0]
			PLUS2 := rhs[1]
			E_S3 := rhs[2]

			E_S0.Child = E_S1
			E_S1.Next = PLUS2
			PLUS2.Next = E_S3

			{
				newValue := parserPools[thread].Get()
				*newValue = *E_S1.Value.(*int64) + *E_S3.Value.(*int64)
				E_S0.Value = newValue
			}
		case 2:
			E_S0 := lhs
			LPAR1 := rhs[0]
			E_S2 := rhs[1]
			RPAR3 := rhs[2]

			E_S0.Child = LPAR1
			LPAR1.Next = E_S2
			E_S2.Next = RPAR3

			{
				E_S0.Value = E_S2.Value
			}
		case 3:
			E_S0 := lhs
			NUMBER1 := rhs[0]

			E_S0.Child = NUMBER1

			{
				E_S0.Value = NUMBER1.Value
			}
		}
	}

	return gopapageno.NewParser(
		NewLexer(),
		numTerminals,
		numNonTerminals,
		maxRHSLen,
		rules,
		compressedRules,
		precMatrix,
		bitPackedMatrix,
		fn,
		opts...)
}
