// Code generated by Gopapageno; DO NOT EDIT.
package main

import (
	"github.com/giornetta/gopapageno"
	"strings"
	"fmt"
)

import (
	"math"
)

var parserInt64Pools []*gopapageno.Pool[int64]

// ParserPreallocMem initializes all the memory pools required by the semantic function of the parser.
func ParserPreallocMem(inputSize int, numThreads int) {
	parserInt64Pools = make([]*gopapageno.Pool[int64], numThreads)

	avgCharsPerNumber := float64(4)
	poolSizePerThread := int(math.Ceil((float64(inputSize) / avgCharsPerNumber) / float64(numThreads)))

	for i := 0; i < numThreads; i++ {
		parserInt64Pools[i] = gopapageno.NewPool[int64](poolSizePerThread)
	}
}


// Non-terminals
const (
	D_E_P_T = gopapageno.TokenEmpty + 1 + iota
	D_T
	P
	S
)

// Terminals
const (
	DIVIDE = gopapageno.TokenTerm + 1 + iota
	LPAR
	NUMBER
	PLUS
	RPAR
)

func SprintToken[ValueType any](root *gopapageno.Token) string {
	var sprintRec func(t *gopapageno.Token, sb *strings.Builder, indent string)

	sprintRec = func(t *gopapageno.Token, sb *strings.Builder, indent string) {
		if t == nil {
			return
		}

		sb.WriteString(indent)
		if t.Next == nil {
			sb.WriteString("└── ")
			indent += "    "
		} else {
			sb.WriteString("├── ")
			indent += "|   "
		}

		switch t.Type {
		case D_E_P_T:
			sb.WriteString("D_E_P_T")
		case D_T:
			sb.WriteString("D_T")
		case P:
			sb.WriteString("P")
		case S:
			sb.WriteString("S")
		case gopapageno.TokenEmpty:
			sb.WriteString("Empty")
		case DIVIDE:
			sb.WriteString("DIVIDE")
		case LPAR:
			sb.WriteString("LPAR")
		case NUMBER:
			sb.WriteString("NUMBER")
		case PLUS:
			sb.WriteString("PLUS")
		case RPAR:
			sb.WriteString("RPAR")
		case gopapageno.TokenTerm:
			sb.WriteString("Term")
		default:
			sb.WriteString("Unknown")
		}

		if t.Value != nil {
			if v, ok := any(t.Value).(*ValueType); ok {
				sb.WriteString(fmt.Sprintf(": %v", *v))
			}
		}
		
		sb.WriteString("\n")
		
		sprintRec(t.Child, sb, indent)
		sprintRec(t.Next, sb, indent[:len(indent)-4])
	}

	var sb strings.Builder
	
	sprintRec(root, &sb, "")
	
	return sb.String()
}

func NewGrammar() *gopapageno.Grammar {
	numTerminals := uint16(6)
	numNonTerminals := uint16(5)

	maxRHSLen := 3
	rules := []gopapageno.Rule{
		{S, []gopapageno.TokenType{D_E_P_T}, gopapageno.RuleSimple},
		{D_T, []gopapageno.TokenType{D_E_P_T, DIVIDE, D_E_P_T}, gopapageno.RuleSimple},
		{P, []gopapageno.TokenType{D_E_P_T, PLUS, D_E_P_T}, gopapageno.RuleCyclic},
		{P, []gopapageno.TokenType{D_E_P_T, PLUS, D_T}, gopapageno.RuleCyclic},
		{S, []gopapageno.TokenType{D_T}, gopapageno.RuleSimple},
		{D_T, []gopapageno.TokenType{D_T, DIVIDE, D_E_P_T}, gopapageno.RuleSimple},
		{P, []gopapageno.TokenType{D_T, PLUS, D_E_P_T}, gopapageno.RuleCyclic},
		{P, []gopapageno.TokenType{D_T, PLUS, D_T}, gopapageno.RuleCyclic},
		{S, []gopapageno.TokenType{P}, gopapageno.RuleSimple},
		{D_E_P_T, []gopapageno.TokenType{LPAR, S, RPAR}, gopapageno.RuleSimple},
		{D_E_P_T, []gopapageno.TokenType{NUMBER}, gopapageno.RuleSimple},
	}
	compressedRules := []uint16{0, 0, 5, 1, 13, 2, 41, 3, 69, 32770, 72, 32771, 85, 4, 0, 2, 32769, 20, 32772, 28, 0, 0, 1, 1, 25, 2, 1, 0, 0, 0, 2, 1, 35, 2, 38, 3, 2, 0, 3, 3, 0, 4, 4, 2, 32769, 48, 32772, 56, 0, 0, 1, 1, 53, 2, 5, 0, 0, 0, 2, 1, 63, 2, 66, 3, 6, 0, 3, 7, 0, 4, 8, 0, 0, 0, 1, 4, 77, 0, 0, 1, 32773, 82, 1, 9, 0, 1, 10, 0	}

	maxPrefixLength := 4
	prefixes := [][]gopapageno.TokenType{
		{D_E_P_T, PLUS, D_E_P_T, PLUS},
		{D_E_P_T, PLUS, D_T, PLUS},
		{D_T, PLUS, D_E_P_T, PLUS},
		{D_T, PLUS, D_T, PLUS},
		{D_E_P_T, PLUS, D_E_P_T, PLUS},
		{D_E_P_T, PLUS, D_T, PLUS},
		{D_T, PLUS, D_E_P_T, PLUS},
		{D_T, PLUS, D_T, PLUS},
		{D_E_P_T, PLUS, D_E_P_T, PLUS},
		{D_E_P_T, PLUS, D_T, PLUS},
		{D_T, PLUS, D_E_P_T, PLUS},
		{D_T, PLUS, D_T, PLUS},
		{D_E_P_T, PLUS, D_E_P_T, PLUS},
		{D_E_P_T, PLUS, D_T, PLUS},
		{D_T, PLUS, D_E_P_T, PLUS},
		{D_T, PLUS, D_T, PLUS},
	}
	compressedPrefixes := []uint16{0, 0, 2, 1, 7, 2, 35, 0, 0, 1, 32772, 12, 0, 0, 2, 1, 19, 2, 27, 0, 0, 1, 32772, 24, 3, 7, 0, 0, 0, 1, 32772, 32, 3, 7, 0, 0, 0, 1, 32772, 40, 0, 0, 2, 1, 47, 2, 55, 0, 0, 1, 32772, 52, 3, 7, 0, 0, 0, 1, 32772, 60, 3, 7, 0	}

	precMatrix := [][]gopapageno.Precedence{
		{gopapageno.PrecEquals, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields},
		{gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecTakes, gopapageno.PrecTakes},
		{gopapageno.PrecTakes, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecEquals},
		{gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecEmpty, gopapageno.PrecEmpty, gopapageno.PrecTakes, gopapageno.PrecTakes},
		{gopapageno.PrecTakes, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecYields, gopapageno.PrecEquals, gopapageno.PrecTakes},
		{gopapageno.PrecTakes, gopapageno.PrecTakes, gopapageno.PrecEmpty, gopapageno.PrecEmpty, gopapageno.PrecTakes, gopapageno.PrecTakes},
	}
	bitPackedMatrix := []uint64{
		12130059261172884820, 160, 
	}

	fn := func(ruleDescription uint16, ruleFlags gopapageno.RuleFlags, lhs *gopapageno.Token, rhs []*gopapageno.Token, thread int){
		switch ruleDescription {
		case 0:
			S0 := lhs
			D_E_P_T1 := rhs[0]

			S0.Child = D_E_P_T1
			S0.LastChild = D_E_P_T1

			{
				S0.Value = D_E_P_T1.Value
			}
			_ = D_E_P_T1
		case 1:
			D_T0 := lhs
			D_E_P_T1 := rhs[0]
			DIVIDE2 := rhs[1]
			D_E_P_T3 := rhs[2]

			D_T0.Child = D_E_P_T1
			D_E_P_T1.Next = DIVIDE2
			DIVIDE2.Next = D_E_P_T3
			D_T0.LastChild = D_E_P_T3

			{
			    newValue := parserInt64Pools[thread].Get()
			    *newValue = *D_E_P_T1.Value.(*int64) / *D_E_P_T3.Value.(*int64)
			    D_T0.Value = newValue
			}
			_ = D_E_P_T1
			_ = DIVIDE2
			_ = D_E_P_T3
		case 2:
			P0 := lhs
			D_E_P_T1 := rhs[0]
			PLUS2 := rhs[1]
			D_E_P_T3 := rhs[2]

			if ruleFlags.Has(gopapageno.RuleAppend) {
				P0.LastChild.Next = PLUS2
			} else {
				P0.Child = D_E_P_T1
				D_E_P_T1.Next = PLUS2
			}

			PLUS2.Next = D_E_P_T3

			if ruleFlags.Has(gopapageno.RuleCombine) {
				PLUS2.Next = D_E_P_T3.Child
				P0.LastChild = D_E_P_T3.LastChild
			} else {
				PLUS2.Next = D_E_P_T3
				P0.LastChild = D_E_P_T3
			}

			{
				newValue := parserInt64Pools[thread].Get()
				*newValue = *D_E_P_T1.Value.(*int64) + *D_E_P_T3.Value.(*int64)
				P0.Value = newValue
			}
			_ = D_E_P_T1
			_ = PLUS2
			_ = D_E_P_T3
		case 3:
			P0 := lhs
			D_E_P_T1 := rhs[0]
			PLUS2 := rhs[1]
			D_T3 := rhs[2]

			if ruleFlags.Has(gopapageno.RuleAppend) {
				P0.LastChild.Next = PLUS2
			} else {
				P0.Child = D_E_P_T1
				D_E_P_T1.Next = PLUS2
			}

			PLUS2.Next = D_T3

			if ruleFlags.Has(gopapageno.RuleCombine) {
				PLUS2.Next = D_T3.Child
				P0.LastChild = D_T3.LastChild
			} else {
				PLUS2.Next = D_T3
				P0.LastChild = D_T3
			}

			{
				newValue := parserInt64Pools[thread].Get()
				*newValue = *D_E_P_T1.Value.(*int64) + *D_T3.Value.(*int64)
				P0.Value = newValue
			}
			_ = D_E_P_T1
			_ = PLUS2
			_ = D_T3
		case 4:
			S0 := lhs
			D_T1 := rhs[0]

			S0.Child = D_T1
			S0.LastChild = D_T1

			{
			    S0.Value = D_T1.Value
			}
			_ = D_T1
		case 5:
			D_T0 := lhs
			D_T1 := rhs[0]
			DIVIDE2 := rhs[1]
			D_E_P_T3 := rhs[2]

			D_T0.Child = D_T1
			D_T1.Next = DIVIDE2
			DIVIDE2.Next = D_E_P_T3
			D_T0.LastChild = D_E_P_T3

			{
			    newValue := parserInt64Pools[thread].Get()
			    *newValue = *D_T1.Value.(*int64) / *D_E_P_T3.Value.(*int64)
			    D_T0.Value = newValue
			}
			_ = D_T1
			_ = DIVIDE2
			_ = D_E_P_T3
		case 6:
			P0 := lhs
			D_T1 := rhs[0]
			PLUS2 := rhs[1]
			D_E_P_T3 := rhs[2]

			if ruleFlags.Has(gopapageno.RuleAppend) {
				P0.LastChild.Next = PLUS2
			} else {
				P0.Child = D_T1
				D_T1.Next = PLUS2
			}

			PLUS2.Next = D_E_P_T3

			if ruleFlags.Has(gopapageno.RuleCombine) {
				PLUS2.Next = D_E_P_T3.Child
				P0.LastChild = D_E_P_T3.LastChild
			} else {
				PLUS2.Next = D_E_P_T3
				P0.LastChild = D_E_P_T3
			}

			{
				newValue := parserInt64Pools[thread].Get()
				*newValue = *D_T1.Value.(*int64) + *D_E_P_T3.Value.(*int64)
				P0.Value = newValue
			}
			_ = D_T1
			_ = PLUS2
			_ = D_E_P_T3
		case 7:
			P0 := lhs
			D_T1 := rhs[0]
			PLUS2 := rhs[1]
			D_T3 := rhs[2]

			if ruleFlags.Has(gopapageno.RuleAppend) {
				P0.LastChild.Next = PLUS2
			} else {
				P0.Child = D_T1
				D_T1.Next = PLUS2
			}

			PLUS2.Next = D_T3

			if ruleFlags.Has(gopapageno.RuleCombine) {
				PLUS2.Next = D_T3.Child
				P0.LastChild = D_T3.LastChild
			} else {
				PLUS2.Next = D_T3
				P0.LastChild = D_T3
			}

			{
				newValue := parserInt64Pools[thread].Get()
				*newValue = *D_T1.Value.(*int64) + *D_T3.Value.(*int64)
				P0.Value = newValue
			}
			_ = D_T1
			_ = PLUS2
			_ = D_T3
		case 8:
			S0 := lhs
			P1 := rhs[0]

			S0.Child = P1
			S0.LastChild = P1

			{
				S0.Value = P1.Value
			}
			_ = P1
		case 9:
			D_E_P_T0 := lhs
			LPAR1 := rhs[0]
			S2 := rhs[1]
			RPAR3 := rhs[2]

			D_E_P_T0.Child = LPAR1
			LPAR1.Next = S2
			S2.Next = RPAR3
			D_E_P_T0.LastChild = RPAR3

			{
				D_E_P_T0.Value = S2.Value
			}
			_ = LPAR1
			_ = S2
			_ = RPAR3
		case 10:
			D_E_P_T0 := lhs
			NUMBER1 := rhs[0]

			D_E_P_T0.Child = NUMBER1
			D_E_P_T0.LastChild = NUMBER1

			{
			    D_E_P_T0.Value = NUMBER1.Value
			}
			_ = NUMBER1
		}
		_ = ruleFlags
	}

	return &gopapageno.Grammar{
		NumTerminals:  numTerminals,
		NumNonterminals: numNonTerminals,
		MaxRHSLength: maxRHSLen,
		Rules: rules,
		CompressedRules: compressedRules,
		PrecedenceMatrix: precMatrix,
		BitPackedPrecedenceMatrix: bitPackedMatrix,
		MaxPrefixLength: maxPrefixLength,
		Prefixes: prefixes,
		CompressedPrefixes: compressedPrefixes,
		Func: fn,
		ParsingStrategy: gopapageno.COPP,
		PreambleFunc: ParserPreallocMem,
	}
}

